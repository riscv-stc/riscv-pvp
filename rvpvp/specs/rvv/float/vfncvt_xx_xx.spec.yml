_: &default
  head: |
    #include "exception.h"
  env: RVTEST_RV64UV
  templates:
    test_basic_without_mask: |
      test_{num}: 
        li TESTNUM, {num};   // {num} set automatically
        li t0, 4;
        fsrm t1, t0;         // set rounding mode as RMM
        li a0, {vl} ; 
        vsetvli t0, a0, e{sew_vs},m{lmul_vs},ta,ma;
        la a2, {vs2_data} ;  // vs2 data label
        vle{sew_vs}.v v16, (a2) ;
        vsetvli x0, x0, e{sew},m{lmul},ta,ma;
        li t0, 0;
        csrw vstart, t0;      // set vstart as 0
        {name} v24, v16;  // {name} is the test instruction
        csrr t0, vstart;
        beqz t0, 1f;          // test if vstart==0 after the instruction
        j fail;
      1:la a3, test_{num}_data; 
        vse{sew}.v v24, (a3);    // save the result data into test_{num}_data memory
        .pushsection .data, 1;
        .balign  ({sew}/8)        
      test_{num}_data:
        .fill {vl}, ({sew}/8), 0;  // there are {vl} sets of ({sew}/8) bytes 0
        .popsection


    test_special_without_mask: |
      test_{num}: 
        li TESTNUM, {num};   // {num} set automatically
        li t0, 4;
        fsrm t1, t0;         // set rounding mode as RMM
        li a0, {vl} ; 
        vsetvli t0, a0, e{sew_vs},m2,ta,ma;
        la a2, {vs2_data} ;  // vs2 data label
        vle{sew_vs}.v v16, (a2) ;
        vsetvli x0, x0, e{sew},m1,ta,ma;
        li t0, 0;
        csrw vstart, t0;      // set vstart as 0
        {name} v24, v16;  // {name} is the test instruction
        csrr t0, vstart;
        beqz t0, 1f;          // test if vstart==0 after the instruction
        j fail;
      1:la a3, test_{num}_data; 
        vse{sew}.v v24, (a3);    // save the result data into test_{num}_data memory
        .pushsection .data, 1;
        .balign  ({sew}/8)        
      test_{num}_data:
        .fill {vl}, ({sew}/8), 0;  // there are {vl} sets of ({sew}/8) bytes 0
        .popsection       
    test_vta_eq_tu_without_mask: |   
      test_{num}: 
        li TESTNUM, {num}; // {num} set automatically            
        li t0, 4;
        fsrm t1, t0;      //set rounding mode as RMM            
        li a0, {vs2_shape[0]} ; // vl of source data = (vlmax, VLEN/SEW)
        vsetvli t0, a0, e{sew_vs},m{lmul_vs},ta,ma;
        la a2, {vs2_data} ;  // vs2 data label
        vle{sew_vs}.v v16, (a2) ;       
        vsetvli x0, x0, e{sew},m{lmul_orig},ta,ma;
        la a3, {orig_data}; // original data label of target register
        vle{sew}.v v24, (a3);
        li a0, {vl} ;       // set vl of test instruction
        vsetvli t0, a0, e{sew},m{lmul},tu,ma;
        li t0, 0;
        csrw vstart, t0;    // set vstart as 0
        {name} v24, v16; // {name} is the test instruction            
      1:li a0, {vs2_shape[0]} ;
        vsetvli t0, a0, e{sew},m{lmul_orig},ta,ma;
        la a3, test_{num}_data; 
        vse{sew}.v v24, (a3);  // save the result data into test_{num}_data memory
        .pushsection .data, 1;
        .balign  ({sew}/8)
      test_{num}_data:
        .fill {vs2_shape[0]}, ({sew}/8), 0;// there are {vs2_shape[0]} sets of ({sew}/8) bytes 0
        .popsection   
    test_rounding_mode_without_mask: |   
      test_{num}: 
        li TESTNUM, {num};   // {num} set automatically
        li t0, {frm};
        fsrm t1, t0;         // set rounding mode 
        li a0, {vl} ; 
        vsetvli t0, a0, e{sew_vs},m{lmul_vs},ta,ma;
        la a2, {vs2_data} ;  // vs2 data label
        vle{sew_vs}.v v16, (a2) ;
        vsetvli x0, x0, e{sew},m{lmul},ta,ma;
        li t0, 0;
        csrw vstart, t0;      // set vstart as 0
        {name} v24, v16;  // {name} is the test instruction
        csrr t0, vstart;
        beqz t0, 1f;          // test if vstart==0 after the instruction
        j fail;
      1:la a3, test_{num}_data; 
        vse{sew}.v v24, (a3);    // save the result data into test_{num}_data memory
        .pushsection .data, 1; 
        .balign  ({sew}/8)
      test_{num}_data:
        .fill {vl}, ({sew}/8), 0;  // there are {vl} sets of ({sew}/8) bytes 0
        .popsection
              
    test_dest_eq_vs2_without_mask: |  
      test_{num}: 
        li TESTNUM, {num};   // {num} set automatically
        li t0, 4;
        fsrm t1, t0;         // set rounding mode as RMM
        li a0, {vl} ; 
        vsetvli t0, a0, e{sew_vs},m{lmul_vs},ta,ma;
        la a2, {vs2_data} ;  // vs2 data label
        vle{sew_vs}.v {vs2_name}, (a2) ;
        vsetvli x0, x0, e{sew},m{lmul},ta,ma;
        li t0, 0;
        csrw vstart, t0;      // set vstart as 0
        {name} {vs2_name}, {vs2_name};  // {name} is the test instruction
        csrr t0, vstart;
        beqz t0, 1f;          // test if vstart==0 after the instruction
        j fail;
      1:la a3, test_{num}_data; 
        vse{sew}.v {vs2_name}, (a3);    // save the result data into test_{num}_data memory
        .pushsection .data, 1; 
        .balign  ({sew}/8)
      test_{num}_data:
        .fill {vl}, ({sew}/8), 0;  // there are {vl} sets of ({sew}/8) bytes 0
        .popsection     
  
    test_basic_with_mask: |
      test_{num}:
        li TESTNUM, {num}; // num set automatically            
        li t0, 4;
        fsrm t1, t0;      //set rounding mode as RMM            
        li a0, {vl} ;  // set vl of test instruction 
        vsetvli t0, a0, e{sew_vs},m{lmul_vs},ta,ma;
        la a2, {vs2_data} ;  // vs2 data label
        vle{sew_vs}.v v16, (a2) ;
        vsetvli x0, x0, e{sew},m{lmul},ta,ma;       
        la a0, {mask_data} ;//v0 data label
        vle1.v v0, (a0);
        li t0, 0;
        csrw vstart, t0; //set vstart as 0 
        {name} v24, v16, v0.t ; // name is the test instruction
        csrr t0, vstart;
        beqz t0, 1f;    // test if vstart==0 after the instruction
        j fail;              
      1:vsetvli x0, x0, e{sew},m{lmul},ta,mu;
        la a3, test_{num}_data; 
        vse{sew}.v v24, (a3), v0.t;# save the result data into test_{num}_data memory
        .pushsection .data, 1;
        .balign  ({sew}/8)
      test_{num}_data:
          .fill {vl}, ({sew}/8), 0;# there are {vl} sets of ({sew}/8) bytes 0
          .popsection
    test_basic_with_mask_mu: |
      test_{num}:
        li TESTNUM, {num}; // num set automatically            
        li t0, 4;
        fsrm t1, t0;      //set rounding mode as RMM            
        li a0, {vl} ;  // set vl of test instruction 
        vsetvli t0, a0, e{sew_vs},m{lmul_vs},ta,ma;
        la a2, {vs2_data} ;  // vs2 data label
        vle{sew_vs}.v v16, (a2) ;
        vsetvli x0, x0, e{sew},m{lmul},ta,mu;        
        la a3, {orig_data}; // original data label of target register
        vle{sew}.v v24, (a3);         
        la a0, {mask_data} ;//v0 data label
        vle1.v v0, (a0);
        li t0, 0;
        csrw vstart, t0; //set vstart as 0 
        {name} v24, v16, v0.t ; // name is the test instruction
        csrr t0, vstart;
        beqz t0, 1f;    // test if vstart==0 after the instruction
        j fail;              
      1:vsetvli x0, x0, e{sew},m{lmul},ta,ma;
        la a3, test_{num}_data; 
        vse{sew}.v v24, (a3);# save the result data into test_{num}_data memory
        .pushsection .data, 1;
        .balign  ({sew}/8)
      test_{num}_data:
          .fill {vl}, ({sew}/8), 0;# there are {vl} sets of ({sew}/8) bytes 0
          .popsection            
    test_vstart_not_eq_zero_without_mask: |   
      test_{num}: 
        li TESTNUM, {num};   // {num} set automatically
        li t0, 4;
        fsrm t1, t0;         // set rounding mode as RMM
        li a0, {vl} ;
        vsetvli t0, a0, e{sew_vs},m{lmul_vs},ta,ma;
        la a2, {vs2_data} ;  // vs2 data label
        vle{sew_vs}.v v16, (a2) ;
        vsetvli x0, x0, e{sew},m{lmul},ta,ma;         
        la a3, {orig_data}; // original data label of target register
        vle{sew}.v v24, (a3);
        li t0, {vstart};
        csrw vstart, t0;      // set vstart
        {name} v24, v16  // {name} is the test instruction
        csrr t0, vstart;
        beqz t0, 1f;          // test if vstart==0 after the instruction
        j fail;
      1:la a3, test_{num}_data; 
        vse{sew}.v v24, (a3);    // save the result data into test_{num}_data memory
        .pushsection .data, 1; 
        .balign  ({sew}/8)
      test_{num}_data:
        .fill {vl}, ({sew}/8), 0;  // there are {vl} sets of ({sew}/8) bytes 0
        .popsection 
    test_vstart_not_eq_zero_with_mask: | 
      test_{num}:
        li TESTNUM, {num}; // num set automatically            
        li t0, 4;
        fsrm t1, t0;      //set rounding mode as RMM            
        li a0, {vl} ;  // set vl of test instruction 
        vsetvli t0, a0, e{sew_vs},m{lmul_vs},ta,ma;
        la a2, {vs2_data} ;  // vs2 data label
        vle{sew_vs}.v v16, (a2) ;
        vsetvli x0, x0, e{sew},m{lmul},ta,ma;         
        la a3, {orig_data}; // original data label of target register 
        vle{sew}.v v24, (a3);               
        la a0, {mask_data} ;//v0 data label
        vle1.v v0, (a0);
        li t0, {vstart};
        csrw vstart, t0; //set vstart
        {name} v24, v16, v0.t ; // name is the test instruction
        csrr t0, vstart;
        beqz t0, 1f;    // test if vstart==0 after the instruction
        j fail;              
      1:vsetvli x0, x0, e{sew},m{lmul},ta,ma;
        la a3, test_{num}_data; 
        vse{sew}.v v24, (a3);# save the result data into test_{num}_data memory
        .pushsection .data, 1;
        .balign  ({sew}/8)
      test_{num}_data:
          .fill {vl}, ({sew}/8), 0;# there are {vl} sets of ({sew}/8) bytes 0
          .popsection
    test_exception_wrong_sew_without_mask: |
      test_{num}: 
        li TESTNUM, {num}; // {num} set automatically            
        li t0, CAUSE_ILLEGAL_INSTRUCTION;
        la t1, _expected_cause;
        sw t0, 0(t1);
        la t0, test_{num}_end;
        la t1, _restore_addr;
        sw t0, 0(t1);          
        li a0, {vl} ;     //vl
        vsetvli t0, a0, e{sew},m{lmul},ta,ma;
        {name} v24, v16; // {name} is the test instruction
        j fail;
      test_{num}_end:
    test_exception_lmul_vreg_no_without_mask: |
      test_{num}: 
        li TESTNUM, {num}; // {num} set automatically              
        li t0, CAUSE_ILLEGAL_INSTRUCTION;
        la t1, _expected_cause;
        sw t0, 0(t1);
        la t0, test_{num}_end;
        la t1, _restore_addr;
        sw t0, 0(t1);       
        li a0, {vl} ;     // vl
        vsetvli t0, a0, e{sew},m{lmul},ta,ma;
        {name} {vd_name}, {vs2_name}; // {name} is the test instruction
        j fail;
      test_{num}_end:
    test_exception_wrong_lmul_without_mask: |
      test_{num}: 
        li TESTNUM, {num}; // {num} set automatically            
        li t0, CAUSE_ILLEGAL_INSTRUCTION;
        la t1, _expected_cause;
        sw t0, 0(t1);
        la t0, test_{num}_end;
        la t1, _restore_addr;
        sw t0, 0(t1);          
        li a0, 1 ;     //vl
        vsetvli t0, a0, e{sew},m{lmul},ta,ma;
        {name} v24, v16; // {name} is the test instruction
        j fail;
      test_{num}_end: 
  rule: co_verification

vfncvt_xu_f_w: &vfncvt_xu_f_w
  <<: *default
  basic_cases:
    test_basic_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : vector_vl_list(lmul, sew, vlen)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_float(sew_vs))    
    test_basic_with_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))         

  cases:
    test_basic_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : vector_vl_list(lmul, sew, vlen)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_float(sew_vs))      

    test_special_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        sew_vs: 2*sew     
        vl  : min(10, vlen // sew)
        vs2 : vector_float_array_special(sew_vs)        

    test_vta_eq_tu_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        lmul_orig: 1 if isinstance(lmul,str) else lmul
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul_orig)
        vl  : list(np.random.choice( vector_vl_list(lmul, sew, vlen), 1))
        vs2 : np.linspace(-300, 500, vector_len_vreg_aligned(lmul, sew, vlen)).astype(bits_to_dtype_float(sew_vs)) 
        orig: np.linspace(-400, 400, vector_len_vreg_aligned(lmul, sew, vlen)).astype(bits_to_dtype_uint(sew))

    test_rounding_mode_without_mask:
      matrix:
        frm: [ 0, 1, 2, 3]
        sew : vector_sew_list_wf(flen)
        lmul: list(np.random.choice( vector_lmul_list_w(sew, flen), 1 ))
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)        
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_float(sew_vs))       

      
    test_dest_eq_vs2_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))
        vs2_name: alloc_vreg( lmul_vs )        
    

    test_basic_with_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))
      
    test_basic_with_mask_mu:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_uint(sew))
      
    test_vstart_not_eq_zero_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_uint(sew))
        vstart:   "list(np.random.choice(vl, 2)) + [ vector_vlmax(lmul, sew, vlen) + 1 ]"

    test_vstart_not_eq_zero_with_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_uint(sew))
        mask: vector_mask_array_random(vl)
        vstart:   "list(np.random.choice(vl, 2)) + [ vector_vlmax(lmul, sew, vlen) + 1 ]"   
  
    test_exception_wrong_sew_without_mask  @ sew, lmul, vl  :
      - [ 64, 1, 15 ]
      - [ 64, 4, 30 ] 
      - [ 64, "f2", 3 ]
      - [ 128, 1, 3 ]
      - [ 128, 2, 10 ]
      - [ 128, 4, 20 ]
      - [ 256, 1, 2 ]
      - [ 256, 4, 10 ]
      - [ 256, 8, 25 ]
      - [ 512, 2, 2 ]
      - [ 512, 4, 5 ]
      - [ 512, 8, 11 ]
      - [ 1024, 1, 1 ]
      - [ 1024, 4, 3 ]
      - [ 1024, 8, 5 ]
    test_exception_lmul_vreg_no_without_mask  @ sew, lmul, vl, vs2_name, vd_name:
      - [ 32, 1, 10, "v11", "v8" ]
      - [ 16, 1, 6, "v25", "v21" ]
      - [ 8, 1, 11, "v27", "v8" ]    
      - [ 32, 2, 35, "v3", "v8" ]
      - [ 8, 2, 15, "v20", "v11" ]
      - [ 16, 4, 77, "v15", "v24" ]
      - [ 32, 4, 37, "v16", "v27" ]
    test_exception_wrong_lmul_without_mask:
      matrix:
        sew : [ 8, 16, 32]
        lmul: vector_illegal_lmul_w(sew)

  random_cases:
    test_vstart_not_eq_zero_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: 1
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : scalar_float_random(sew_vs, vl)   
        orig:  scalar_uint_random(sew, vl)
        vstart:   np.random.randint(0, vl)

    test_vstart_not_eq_zero_with_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: 1
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : scalar_float_random(sew_vs, vl)   
        orig:  scalar_uint_random(sew, vl)
        mask: vector_mask_array_random(vl)
        vstart:   np.random.randint(0, vl)
    

  rule_params:
    test_basic_without_mask: np.equal( result, golden ).all()     
    test_special_without_mask: np.equal( result, golden ).all() 
    test_vta_eq_tu_without_mask: np.equal( result, golden ).all() 
    test_rounding_mode_without_mask: np.equal( result, golden ).all()
    test_dest_eq_vs2_without_mask: np.equal( result, golden ).all()
    test_basic_with_mask: np.equal( result, golden ).all()
    test_basic_with_mask_mu: np.equal( result, golden ).all()
    test_vstart_not_eq_zero_without_mask: np.equal( result, golden ).all()
    test_vstart_not_eq_zero_with_mask: np.equal( result, golden ).all()
  

vfncvt_x_f_w: &vfncvt_x_f_w
  <<: *default
  basic_cases:
    test_basic_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : vector_vl_list(lmul, sew, vlen)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_float(sew_vs))    
    test_basic_with_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))         

  cases:
    test_basic_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : vector_vl_list(lmul, sew, vlen)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_float(sew_vs))      

    test_special_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        sew_vs: 2*sew     
        vl  : min(10, vlen // sew)
        vs2 : vector_float_array_special(sew_vs)        

    test_vta_eq_tu_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        lmul_orig: 1 if isinstance(lmul,str) else lmul
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul_orig)
        vl  : list(np.random.choice( vector_vl_list(lmul, sew, vlen), 1))
        vs2 : np.linspace(-300, 500, vector_len_vreg_aligned(lmul, sew, vlen)).astype(bits_to_dtype_float(sew_vs)) 
        orig: np.linspace(-400, 400, vector_len_vreg_aligned(lmul, sew, vlen)).astype(bits_to_dtype_int(sew))

    test_rounding_mode_without_mask:
      matrix:
        frm: [ 0, 1, 2, 3]
        sew : vector_sew_list_wf(flen)
        lmul: list(np.random.choice( vector_lmul_list_w(sew, flen), 1 ))
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)        
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_float(sew_vs))       

      
    test_dest_eq_vs2_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))
        vs2_name: alloc_vreg( lmul_vs )        
    

    test_basic_with_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))
      
    test_basic_with_mask_mu:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_int(sew))
      
    test_vstart_not_eq_zero_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_int(sew))
        vstart:   "list(np.random.choice(vl, 2)) + [ vector_vlmax(lmul, sew, vlen) + 1 ]"

    test_vstart_not_eq_zero_with_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_int(sew))
        mask: vector_mask_array_random(vl)
        vstart:   "list(np.random.choice(vl, 2)) + [ vector_vlmax(lmul, sew, vlen) + 1 ]"   
  
    test_exception_wrong_sew_without_mask  @ sew, lmul, vl  :
      - [ 64, 1, 15 ]
      - [ 64, 4, 30 ] 
      - [ 64, "f2", 3 ]
      - [ 128, 1, 3 ]
      - [ 128, 2, 10 ]
      - [ 128, 4, 20 ]
      - [ 256, 1, 2 ]
      - [ 256, 4, 10 ]
      - [ 256, 8, 25 ]
      - [ 512, 2, 2 ]
      - [ 512, 4, 5 ]
      - [ 512, 8, 11 ]
      - [ 1024, 1, 1 ]
      - [ 1024, 4, 3 ]
      - [ 1024, 8, 5 ]
    test_exception_lmul_vreg_no_without_mask  @ sew, lmul, vl, vs2_name, vd_name:
      - [ 32, 1, 10, "v11", "v8" ]
      - [ 16, 1, 6, "v25", "v21" ]
      - [ 8, 1, 11, "v27", "v8" ]    
      - [ 32, 2, 35, "v3", "v8" ]
      - [ 8, 2, 15, "v20", "v11" ]
      - [ 16, 4, 77, "v15", "v24" ]
      - [ 32, 4, 37, "v16", "v27" ]
    test_exception_wrong_lmul_without_mask:
      matrix:
        sew : [ 8, 16, 32]
        lmul: vector_illegal_lmul_w(sew)

  random_cases:
    test_vstart_not_eq_zero_without_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: 1
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : scalar_float_random(sew_vs, vl)   
        orig:  scalar_int_random(sew, vl)
        vstart:   np.random.randint(0, vl)

    test_vstart_not_eq_zero_with_mask:
      matrix:
        sew : vector_sew_list_wf(flen)
        lmul: 1
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : scalar_float_random(sew_vs, vl)   
        orig:  scalar_int_random(sew, vl)
        mask: vector_mask_array_random(vl)
        vstart:   np.random.randint(0, vl)
   
  

  rule_params:
    test_basic_without_mask: np.equal( result, golden ).all()     
    test_special_without_mask: np.equal( result, golden ).all() 
    test_vta_eq_tu_without_mask: np.equal( result, golden ).all() 
    test_rounding_mode_without_mask: np.equal( result, golden ).all()
    test_dest_eq_vs2_without_mask: np.equal( result, golden ).all()
    test_basic_with_mask: np.equal( result, golden ).all()
    test_basic_with_mask_mu: np.equal( result, golden ).all()
    test_vstart_not_eq_zero_without_mask: np.equal( result, golden ).all()
    test_vstart_not_eq_zero_with_mask: np.equal( result, golden ).all()
  

vfncvt_rtz_xu_f_w:
  <<: *vfncvt_xu_f_w


vfncvt_rtz_x_f_w:
  <<: *vfncvt_x_f_w

vfncvt_f_xu_w: 
  <<: *default
  basic_cases:
    test_basic_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : vector_vl_list(lmul, sew, vlen)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_uint(sew_vs))    
    test_basic_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_uint(sew_vs))         

  cases:
    test_basic_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : vector_vl_list(lmul, sew, vlen)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_uint(sew_vs))           

    test_vta_eq_tu_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        lmul_orig: 1 if isinstance(lmul,str) else lmul
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul_orig)
        vl  : list(np.random.choice( vector_vl_list(lmul, sew, vlen), 1))
        vs2 : np.linspace(-300, 500, vector_len_vreg_aligned(lmul, sew, vlen)).astype(bits_to_dtype_uint(sew_vs)) 
        orig: np.linspace(-400, 400, vector_len_vreg_aligned(lmul, sew, vlen)).astype(bits_to_dtype_float(sew))

    test_rounding_mode_without_mask:
      matrix:
        frm: [ 0, 1, 2, 3]
        sew : vector_sew_list_fw(flen)
        lmul: list(np.random.choice( vector_lmul_list_w(sew, flen), 1 ))
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)        
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_uint(sew_vs))       

      
    test_dest_eq_vs2_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_uint(sew_vs))
        vs2_name: alloc_vreg( lmul_vs )        
    

    test_basic_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_uint(sew_vs))
      
    test_basic_with_mask_mu:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_uint(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_float(sew))
      
    test_vstart_not_eq_zero_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_uint(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_float(sew))
        vstart:   "list(np.random.choice(vl, 2)) + [ vector_vlmax(lmul, sew, vlen) + 1 ]"

    test_vstart_not_eq_zero_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_uint(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_float(sew))
        mask: vector_mask_array_random(vl)
        vstart:   "list(np.random.choice(vl, 2)) + [ vector_vlmax(lmul, sew, vlen) + 1 ]"   
  
    test_exception_wrong_sew_without_mask  @ sew, lmul, vl  :
      - [  8, 1, 35 ]
      - [  8, "f2", 31 ]
      - [  8, "f4", 17 ]            
      - [ 64, 1, 15 ]
      - [ 64, 4, 30 ] 
      - [ 64, "f2", 3 ]
      - [ 128, 1, 3 ]
      - [ 128, 2, 10 ]
      - [ 128, 4, 20 ]
      - [ 256, 1, 2 ]
      - [ 256, 4, 10 ]
      - [ 256, 8, 25 ]
      - [ 512, 2, 2 ]
      - [ 512, 4, 5 ]
      - [ 512, 8, 11 ]
      - [ 1024, 1, 1 ]
      - [ 1024, 4, 3 ]
      - [ 1024, 8, 5 ]
    test_exception_lmul_vreg_no_without_mask  @ sew, lmul, vl, vs2_name, vd_name:
      - [ 32, 1, 10, "v11", "v8" ]
      - [ 16, 1, 6, "v25", "v21" ]  
      - [ 32, 2, 35, "v3", "v8" ]
      - [ 16, 2, 15, "v20", "v11" ]
      - [ 16, 4, 77, "v15", "v24" ]
      - [ 32, 4, 37, "v16", "v27" ]
    test_exception_wrong_lmul_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_illegal_lmul_w(sew)

  random_cases:
    test_vstart_not_eq_zero_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: 1
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : scalar_uint_random(sew_vs, vl)   
        orig:  scalar_float_random(sew, vl)
        vstart:   np.random.randint(0, vl)

    test_vstart_not_eq_zero_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: 1
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : scalar_uint_random(sew_vs, vl)   
        orig:  scalar_float_random(sew, vl)
        mask: vector_mask_array_random(vl)
        vstart:   np.random.randint(0, vl)
   


  rule_params:
    test_basic_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)    
    test_vta_eq_tu_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_rounding_mode_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_dest_eq_vs2_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_basic_with_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_basic_with_mask_mu: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_vstart_not_eq_zero_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_vstart_not_eq_zero_with_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
  


vfncvt_f_x_w: 
  <<: *default
  basic_cases:
    test_basic_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : vector_vl_list(lmul, sew, vlen)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_int(sew_vs))    
    test_basic_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_int(sew_vs))         

  cases:
    test_basic_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : vector_vl_list(lmul, sew, vlen)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_int(sew_vs))           

    test_vta_eq_tu_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        lmul_orig: 1 if isinstance(lmul,str) else lmul
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul_orig)
        vl  : list(np.random.choice( vector_vl_list(lmul, sew, vlen), 1))
        vs2 : np.linspace(-300, 500, vector_len_vreg_aligned(lmul, sew, vlen)).astype(bits_to_dtype_int(sew_vs)) 
        orig: np.linspace(-400, 400, vector_len_vreg_aligned(lmul, sew, vlen)).astype(bits_to_dtype_float(sew))

    test_rounding_mode_without_mask:
      matrix:
        frm: [ 0, 1, 2, 3]
        sew : vector_sew_list_fw(flen)
        lmul: list(np.random.choice( vector_lmul_list_w(sew, flen), 1 ))
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)        
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_int(sew_vs))       

      
    test_dest_eq_vs2_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_int(sew_vs))
        vs2_name: alloc_vreg( lmul_vs )        
    

    test_basic_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_int(sew_vs))
      
    test_basic_with_mask_mu:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_int(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_float(sew))
      
    test_vstart_not_eq_zero_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_int(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_float(sew))
        vstart:   "list(np.random.choice(vl, 2)) + [ vector_vlmax(lmul, sew, vlen) + 1 ]"

    test_vstart_not_eq_zero_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_int(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_float(sew))
        mask: vector_mask_array_random(vl)
        vstart:   "list(np.random.choice(vl, 2)) + [ vector_vlmax(lmul, sew, vlen) + 1 ]"   
  
    test_exception_wrong_sew_without_mask  @ sew, lmul, vl  :
      - [  8, 1, 35 ]
      - [  8, "f2", 31 ]
      - [  8, "f4", 17 ]            
      - [ 64, 1, 15 ]
      - [ 64, 4, 30 ] 
      - [ 64, "f2", 3 ]
      - [ 128, 1, 3 ]
      - [ 128, 2, 10 ]
      - [ 128, 4, 20 ]
      - [ 256, 1, 2 ]
      - [ 256, 4, 10 ]
      - [ 256, 8, 25 ]
      - [ 512, 2, 2 ]
      - [ 512, 4, 5 ]
      - [ 512, 8, 11 ]
      - [ 1024, 1, 1 ]
      - [ 1024, 4, 3 ]
      - [ 1024, 8, 5 ]
    test_exception_lmul_vreg_no_without_mask  @ sew, lmul, vl, vs2_name, vd_name:
      - [ 32, 1, 10, "v11", "v8" ]
      - [ 16, 1, 6, "v25", "v21" ]  
      - [ 32, 2, 35, "v3", "v8" ]
      - [ 16, 2, 15, "v20", "v11" ]
      - [ 16, 4, 77, "v15", "v24" ]
      - [ 32, 4, 37, "v16", "v27" ]
    test_exception_wrong_lmul_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_illegal_lmul_w(sew)

  random_cases:
    test_vstart_not_eq_zero_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: 1
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : scalar_int_random(sew_vs, vl)   
        orig:  scalar_float_random(sew, vl)
        vstart:   np.random.randint(0, vl)

    test_vstart_not_eq_zero_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: 1
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : scalar_int_random(sew_vs, vl)   
        orig:  scalar_float_random(sew, vl)
        mask: vector_mask_array_random(vl)
        vstart:   np.random.randint(0, vl)


  rule_params:
    test_basic_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)    
    test_vta_eq_tu_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_rounding_mode_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_dest_eq_vs2_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_basic_with_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_basic_with_mask_mu: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_vstart_not_eq_zero_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_vstart_not_eq_zero_with_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
  


vfncvt_f_f_w: &vfncvt_f_f_w
  <<: *default
  basic_cases:
    test_basic_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : vector_vl_list(lmul, sew, vlen)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_float(sew_vs))    
    test_basic_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))         

  cases:
    test_basic_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : vector_vl_list(lmul, sew, vlen)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_float(sew_vs))      

    test_special_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        sew_vs: 2*sew     
        vl  : min(10, vlen // sew)
        vs2 : vector_float_array_special(sew_vs)        

    test_vta_eq_tu_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        lmul_orig: 1 if isinstance(lmul,str) else lmul
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul_orig)
        vl  : list(np.random.choice( vector_vl_list(lmul, sew, vlen), 1))
        vs2 : np.linspace(-300, 500, vector_len_vreg_aligned(lmul, sew, vlen)).astype(bits_to_dtype_float(sew_vs)) 
        orig: np.linspace(-400, 400, vector_len_vreg_aligned(lmul, sew, vlen)).astype(bits_to_dtype_float(sew))

    test_rounding_mode_without_mask:
      matrix:
        frm: [ 0, 1, 2, 3]
        sew : vector_sew_list_fw(flen)
        lmul: list(np.random.choice( vector_lmul_list_w(sew, flen), 1 ))
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)        
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, vl).astype(bits_to_dtype_float(sew_vs))       

      
    test_dest_eq_vs2_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))
        vs2_name: alloc_vreg( lmul_vs )        
    

    test_basic_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))
      
    test_basic_with_mask_mu:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        mask: vector_mask_array_random(vl)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_float(sew))
      
    test_vstart_not_eq_zero_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_float(sew))
        vstart:   "list(np.random.choice(vl, 2)) + [ vector_vlmax(lmul, sew, vlen) + 1 ]"

    test_vstart_not_eq_zero_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_lmul_list_w(sew, flen)
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : np.linspace(-300, 500, int(vl)).astype(bits_to_dtype_float(sew_vs))   
        orig:  np.linspace(-400, 400, int(vl)).astype(bits_to_dtype_float(sew))
        mask: vector_mask_array_random(vl)
        vstart:   "list(np.random.choice(vl, 2)) + [ vector_vlmax(lmul, sew, vlen) + 1 ]"   
  
    test_exception_wrong_sew_without_mask  @ sew, lmul, vl  :
      - [  8, 1, 35 ]
      - [  8, "f2", 31 ]
      - [  8, "f4", 17 ]     
      - [ 64, 1, 15 ]
      - [ 64, 4, 30 ] 
      - [ 64, "f2", 3 ]
      - [ 128, 1, 3 ]
      - [ 128, 2, 10 ]
      - [ 128, 4, 20 ]
      - [ 256, 1, 2 ]
      - [ 256, 4, 10 ]
      - [ 256, 8, 25 ]
      - [ 512, 2, 2 ]
      - [ 512, 4, 5 ]
      - [ 512, 8, 11 ]
      - [ 1024, 1, 1 ]
      - [ 1024, 4, 3 ]
      - [ 1024, 8, 5 ]
    test_exception_lmul_vreg_no_without_mask  @ sew, lmul, vl, vs2_name, vd_name:
      - [ 32, 1, 10, "v11", "v8" ]
      - [ 16, 1, 6, "v25", "v21" ]
      - [ 8, 1, 11, "v27", "v8" ]    
      - [ 32, 2, 35, "v3", "v8" ]
      - [ 8, 2, 15, "v20", "v11" ]
      - [ 16, 4, 77, "v15", "v24" ]
      - [ 32, 4, 37, "v16", "v27" ]
    test_exception_wrong_lmul_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: vector_illegal_lmul_w(sew)

  random_cases:
    test_vstart_not_eq_zero_without_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: 1
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : scalar_float_random(sew_vs, vl)   
        orig:  scalar_float_random(sew, vl)
        vstart:   np.random.randint(0, vl)

    test_vstart_not_eq_zero_with_mask:
      matrix:
        sew : vector_sew_list_fw(flen)
        lmul: 1
        sew_vs: 2*sew
        lmul_vs: vector_widen_lmul(lmul)
        vl  : np.random.randint(1, vector_vlmax(lmul, sew, vlen) + 1)
        vs2 : scalar_float_random(sew_vs, vl)   
        orig:  scalar_float_random(sew, vl)
        mask: vector_mask_array_random(vl)
        vstart:   np.random.randint(0, vl)
   

  rule_params:
    test_basic_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True) 
    test_special_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True) 
    test_vta_eq_tu_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_rounding_mode_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_dest_eq_vs2_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_basic_with_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_basic_with_mask_mu: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_vstart_not_eq_zero_without_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
    test_vstart_not_eq_zero_with_mask: np.allclose( result, golden, rtol=1e-3, atol=0, equal_nan=True)
  

vfncvt_rod_f_f_w:
  <<: *vfncvt_f_f_w